## 先说导出Excel用到的相关原生API：

1. ArrayBuffer（二进制数组）
2. Blob（一个不可变、原始数据的类文件对象）
3. URL（包含若干静态方法的对象，用来创建 URLs）

如果你对上面三个API任意一个感到生疏，那我就当作不知道 ：）



## 封装 JS 文件

**导出Excel实现代码**

```js
`// 引入导出Excel的依赖包``import` `XLSX from ``'xlsx'``;` `let colMap = {};` `// 将指定的自然数转换为26进制表示。映射关系：[0-25] -> [A-Z]。``function getCharCol(n) {``  ``let s = ``''``;``  ``let m = ``0``;``  ``let num = n;``  ``while` `(num > ``0``) {``    ``m = (num % ``26``) + ``1``;``    ``s = String.fromCharCode(m + ``64``) + s;``    ``num = (num - m) / ``26``;``  ``}``  ``return` `s;``}` `// 字符串转字符流``function s2ab(s) {``  ``const` `buf = ``new` `ArrayBuffer(s.length);``  ``const` `view = ``new` `Uint8Array(buf);``  ``for` `(let i = ``0``; i !== s.length; ++i) {``    ``view[i] = s.charCodeAt(i) & ``0xFF``;``  ``}``  ``return` `buf;``}`  `// 导出到 excel 方法``//   - json：要导出的数据，包括表头``//   - downName：要导出的文件名``//   - type：要导出的类型``function downloadExl(json, downName, type) { ``  ``// 创建空数组，保存数据的所有属性（key）``  ``const` `keyMap = [];` `  ``// 比如要导出的数据是[ { name : 'iyunxiao' , email : '123@iyunxiao.com' } ],则 keyMap 保存的结果是['name','email']``  ``for` `(``const` `k in json[``0``]) {``    ``keyMap.push(k);``  ``}``  ` `  ``// 用来保存转换好的json``  ``const` `tmpdata = [];``  `     `  ``// 进行数据转换``  ``// v：要导出到每一条数据对象``  ``// i：要导出的每一条数据对象的索引``  ``// k：keyMap保存的每一个key``  ``// j：keyMap中每一个key对应的索引`  `  ``// position：每条数据值对应的单元格的位置。如果j小于等于25（0～25对应英文中的A-Z）;``  ``//           如果j大于25，则调用getCharCol方法取得复合英文（如AD）,然后把获得的英文字母当作列标，配合i+1（i+1为行标），就得到了每一个对象对应的单元格的位置;``  ``json.map((v, i) => keyMap.map((k, j) => Object.assign({}, {``    ``v: v[k], ``// v: 每一个属性对应的值``    ``position: (j > ``25` `? getCharCol(j) : String.fromCharCode(``65` `+ j)) + (i + ``1``)``  ``}))).reduce((prev, next) => prev.concat(next)).forEach((v) => {``    ``tmpdata[v.position] = {``      ``v: colMap[v.v] || v.v``    ``};``  ``});`   `  ``// 设置区域,比如表格从A1到D10``  ``const` `outputPos = Object.keys(tmpdata);``  ``// tmpWB：tempWorkBook，临时工作簿对象``  ``const` `tmpWB = {``    ``SheetNames: [``'mySheet'``], ``// 保存的表标题``    ``Sheets: { ``// sheet页数据``      ``mySheet: Object.assign({},``        ``tmpdata, ``// 内容``        ``{``          ``'!ref'``: `${outputPos[``0``]}:${outputPos[outputPos.length - ``1``]}` ``// 设置填充区域``        ``})``    ``}``  ``};``  ``const` `tmpDown = ``new` `Blob(``    ``[s2ab(XLSX.write(tmpWB,``      ``{ bookType: (type === undefined ? ``'xlsx'` `: type), bookSST: ``false``, type: ``'binary'` `} ``// 这里的数据是用来定义导出的格式类型``    ``))],``    ``{``      ``type: ``''``    ``}``  ``);  ``// 创建二进制对象写入转换好的字节流` `  ``const` `href = URL.createObjectURL(tmpDown); ``// 创建对象超链接``  ``const` `a = document.createElement(``'a'``);``  ``a.download = `${downName}.xlsx`; ``// 下载名称``  ``a.href = href; ``// 绑定a标签``  ``a.click(); ``// 模拟点击实现下载``  ``setTimeout(() => {  ``// 延时释放``    ``URL.revokeObjectURL(tmpDown);``// 用URL.revokeObjectURL()来释放这个object URL``  ``}, ``100``);``}`   `// 导出EXCEL``//   - rs：要导出的数据``//   - stateMap：字段关系映射``//   - downname：要导出的文件的名字``function downloadFile(rs, stateMap, downName) {``  ``colMap = stateMap;``  ``const` `fileName = downName || ``'下载文件'``;``// 如果指定了下载文件名称就取传入的文件名称，否则就默认为‘下载文件’``  ``let data = [{}];``// 手动添加一行空数据作为表头``  ``for` `(``const` `k in rs[``0``]) {``// 遍历要导出的数据的第一项``    ``data[``0``][k] = k;``// 取第一项的所有key，然后赋值给刚刚手动添加的空表头数据对象``  ``}``  ``data = data.concat(rs);``// 把空表头数据和要导出的数据合并``  ``downloadExl(data, fileName);``// 调用downloadExl方法``}`  `// eg:``// rs: [{name: 'chping', email: 'chengping@iyunxiao.com', sex: '男'， dep: 'BOSSRD'},{name: 'guoshuai', email: 'guoshuai@iyunxiao.com', sex: '男'， dep: 'BOSSRD'}]``// stateMap: {name: '姓名'，email: 'E-mail’， sex: '性别', dep: '部门'}`  `export ``default` `downloadFile;`
```